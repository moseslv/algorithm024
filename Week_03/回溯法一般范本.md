## 参考
## leetcode46. 全排列
####链接 https://leetcode-cn.com/problems/permutations/solution/46-quan-pai-lie-hui-su-fa-by-jue-qiang-z-jym3/


个人理解：回溯法解决问题的过程，实际就是对一颗决策树的遍历过程。

回溯法的三个基本要素：

	路径：已经做出的选择；
	选择列表：当前可以做出的选择；
	结束条件：结束一次回溯算法的条件，即遍历到决策树的叶节点；


回溯法解决问题的通用框架为：
### 回溯算法，复杂度较高，因为回溯算法就是暴力穷举，遍历整颗决策树是不可避免的

结果 = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        结果.append(路径)
        return
    for 选择 in 选择列表:    # 核心代码段
        做出选择
        递归执行backtrack
        撤销选择

写 backtrack 函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集。

注意：对于回溯算法，不管怎么优化，回溯算法的时间复杂度都不可能低于O(N!)，因为回溯算法本质上是穷举，穷举整颗决策树是不可避免的，这也是回溯算法的缺点，复杂度很高。

以这道题的全排列[1, 2, 3]为例，解决问题时，按高中时的思维，先固定第一位（如1），再固定第二位（如2），此时第三位只能是3；接下来，第一位仍固定为1，第二位固定为3，此时第三位只能是2；接下来改变第一位，再继续向下执行上述过程。这个过程可以用一颗决策树表示（图片来源于网络，转侵删）：
